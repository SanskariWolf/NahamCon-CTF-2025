# Vulnerability Analysis
The core of the challenge lies in understanding how the encryption key is generated and reused.
1.  **Encryption:**
    The server uses a simple XOR cipher:
    ```python
    def encrypt(data: bytes, key: bytes) -> bytes:
        """Encrypt data using XOR with the given key."""
        return bytes(a ^ b for a, b in zip(data, key))
    ```
    This means `ciphertext = plaintext XOR key`. Consequently, `plaintext = ciphertext XOR key`.
2.  **Key Generation:**
    The key is generated by:
    ```python
    def generate_key(length: int, seed: Optional[float] = None) -> bytes:
        """Generate a random key of given length using the provided seed."""
        if seed is not None:
            random.seed(int(seed)) # Key point: seed is cast to int
        return bytes(random.randint(0, 255) for _ in range(length))
    ```
    The Python `random` module is a pseudo-random number generator (PRNG). Seeding it with the same integer value will cause it to produce the same sequence of "random" numbers. The `int(seed)` part means any fractional component of the seed is truncated.
3.  **Vulnerability in `handle_client`:**
    Inside the `handle_client` function, the following occurs for each new connection:
    *   `current_time = int(time.time())`: The current Unix timestamp is fetched and cast to an integer. This `current_time` value is **fixed for the entire duration of that client's session**.
    *   `key = generate_key(len(flag), current_time)`: The flag is encrypted using a key generated with `len(flag)` and this fixed `current_time` as the seed.
    *   The `encrypted_flag` is sent to the client.
    *   The server then enters a loop, allowing the client to send data to be encrypted:
        *   `key = generate_key(len(data), current_time)`: When the client sends data, a new key is generated using the length of the client's data (`len(data)`) but with the **exact same `current_time` seed** that was used for encrypting the flag.
        *   `encrypted_data = encrypt(data, key)`: The client's data is encrypted with this new key.
    The critical vulnerability is: **If the client sends data such that `len(data) == len(flag)`, then `generate_key(len(data), current_time)` will produce the exact same key that was used to encrypt the flag.** This is because `random.seed(int(current_time))` will reset the PRNG to the identical state, and `random.randint()` will be called `len(flag)` times, producing the same sequence of bytes for the key.

# Exploitation Strategy (Known-Plaintext Attack Variant)
This vulnerability allows for a type of known-plaintext attack.
Let:
*   `Flag` be the unknown plaintext flag.
*   `K` be the encryption key, generated using `generate_key(len(Flag), current_time)`.
*   `C_flag` be the encrypted flag we receive: `C_flag = Flag XOR K`.
Our goal is to find `Flag`. If we can find `K`, then `Flag = C_flag XOR K`.
We can exploit the vulnerability as follows:
1.  Connect to the server and receive `C_flag`.
2.  Determine the length of the flag, `len_flag = len(C_flag)`.
3.  Construct a known plaintext, `P_known`, such that `len(P_known) == len_flag`. A simple choice is a string of null bytes: `P_known = b'\x00' * len_flag`.
4.  Send `P_known` to the server for encryption.
5.  The server will encrypt `P_known` using `K` (because `len(P_known) == len_flag` and the seed `current_time` is the same). It will return `C_known = P_known XOR K`.
6.  If we chose `P_known` as all null bytes, then `C_known = (b'\x00' * len_flag) XOR K`. Since `0 XOR x = x`, this simplifies to `C_known = K`.
    Thus, the encrypted version of our null-byte string that the server sends back *is the encryption key `K` itself*.
7.  Now that we have `C_flag` (from the server initially) and `K` (which is `C_known`), we can find the flag:
    `Flag = C_flag XOR K` (which is `C_flag XOR C_known`).

# Steps to Reproduce
1.  Connect to the server `nc challenge.nahamcon.com 31098`.
2.  Receive the welcome message and parse out the hex-encoded `encrypted_flag`. Decode this hex string into bytes (`C_flag_bytes`).
3.  Calculate the length of the flag: `flag_len = len(C_flag_bytes)`.
4.  Create a payload of null bytes of this length: `payload_to_send = b'\x00' * flag_len`.
5.  Send this `payload_to_send` to the server.
6.  Receive the server's response, which will be the hex-encoded encryption of our payload. Parse this out and decode it into bytes (`encrypted_payload_bytes`). This is our key `K`.
7.  XOR the original `C_flag_bytes` with `encrypted_payload_bytes` to get the decrypted flag bytes.
8.  Decode the decrypted flag bytes (likely UTF-8) to get the flag string.

# Solution Script
```python
#!/usr/bin/env python3
from pwn import * # Using pwntools for convenience
# Server details
HOST = "challenge.nahamcon.com"
PORT = 31098
def xor_bytes(b1: bytes, b2: bytes) -> bytes:
    """XOR two byte strings. Assumes they are of equal length."""
    return bytes(x ^ y for x, y in zip(b1, b2))
# Connect to the server
log.info(f"Connecting to {HOST}:{PORT}")
conn = remote(HOST, PORT)
# Receive initial messages
welcome_msg_part1 = conn.recvline().decode().strip()
log.info(f"Server: {welcome_msg_part1}") # "Welcome to Cryptoclock!"
encrypted_flag_line = conn.recvline().decode().strip()
log.info(f"Server: {encrypted_flag_line}") # "The encrypted flag is: <hex_string>"
prompt_line = conn.recvline().decode().strip()
log.info(f"Server: {prompt_line}") # "Enter text to encrypt (or 'quit' to exit):"
# Extract the encrypted flag (hex encoded)
prefix_flag = "The encrypted flag is: "
if not encrypted_flag_line.startswith(prefix_flag):
    log.error("Unexpected format for encrypted flag line.")
    conn.close()
    exit(1)
encrypted_flag_hex = encrypted_flag_line[len(prefix_flag):]
C_flag_bytes = bytes.fromhex(encrypted_flag_hex)
log.info(f"Received encrypted flag (hex): {encrypted_flag_hex}")
log.success(f"Received encrypted flag (bytes): {C_flag_bytes}")
# Determine the length of the flag/key
flag_len = len(C_flag_bytes)
log.info(f"Inferred flag length: {flag_len}")
# Create a plaintext of null bytes of the same length as the flag
P_known_null_bytes = b'\x00' * flag_len
log.info(f"Sending {flag_len} null bytes as plaintext to recover the key.")
# Send our chosen plaintext
conn.sendline(P_known_null_bytes)
# Receive the encrypted version of our null bytes
# The line looks like "Encrypted: <hex_string>"
encrypted_data_line = conn.recvline().decode().strip()
log.info(f"Server: {encrypted_data_line}")
prefix_enc_data = "Encrypted: "
if not encrypted_data_line.startswith(prefix_enc_data):
    log.error("Unexpected format for encrypted data line.")
    conn.close()
    exit(1)
encrypted_data_hex = encrypted_data_line[len(prefix_enc_data):]
# Since P_known was null bytes, C_known (encrypted_data_bytes) is the key K.
# C_known = (P_known_null_bytes XOR K) = K
K_bytes = bytes.fromhex(encrypted_data_hex)
log.info(f"Received encrypted null bytes (hex): {encrypted_data_hex}")
log.success(f"This is effectively the key (K) used for flag encryption: {K_bytes}")
# Now, decrypt the flag: Flag = C_flag XOR K
decrypted_flag_bytes = xor_bytes(C_flag_bytes, K_bytes)
try:
    decrypted_flag_str = decrypted_flag_bytes.decode('utf-8')
    log.success(f"Decrypted flag: {decrypted_flag_str}")
except UnicodeDecodeError:
    log.warning(f"Could not decode flag as UTF-8. Raw bytes: {decrypted_flag_bytes}")
    log.success(f"Decrypted flag (hex): {decrypted_flag_bytes.hex()}")
# Clean up
conn.close()
log.info("Connection closed.")
```

# Execution and Flag
Running the script against the server:

```
$ python solve.py
[*] Connecting to challenge.nahamcon.com:31098
[+] Opening connection to challenge.nahamcon.com on port 31098: Done
[*] Server: Welcome to Cryptoclock!
[*] Server: The encrypted flag is: d2871a861e5804d6fc6789e6ca9c56c84397e6114fca5de421aa1631de54c2eca88131bdf414
[*] Server: Enter text to encrypt (or 'quit' to exit):
[*] Received encrypted flag (hex): d2871a861e5804d6fc6789e6ca9c56c84397e6114fca5de421aa1631de54c2eca88131bdf414
[+] Received encrypted flag (bytes): b'\xd2\x87\x1a\x86\x1eX\x04\xd6\xfcg\x89\xe6\xca\x9cV\xc8C\x97\xe6\x11O\xca]\xe4!\xaa\x161\xdeT\xc2\xec\xa8\x811\xbd\xf4\x14'
[*] Inferred flag length: 38
[*] Sending 38 null bytes as plaintext to recover the key.
[*] Server: Encrypted: b4eb7be1656861e2ce05e8d7f2ac66f07af483272af93f86149a7304ec61fadbccb2068fc069
[*] Received encrypted null bytes (hex): b4eb7be1656861e2ce05e8d7f2ac66f07af483272af93f86149a7304ec61fadbccb2068fc069
[+] This is effectively the key (K) used for flag encryption: b"\xb4\xeb{\xe1eha\xe2\xce\x05\xe8\xd7\xf2\xacf\xf0z\xf4\x83'*\xf9?\x86\x14\x9as\x04\xeca\xfa\xdb\xcc\xb2\x06\x8f\xc0i"
[+] Decrypted flag: flag{0e42ba180089ce6e3bb50e52587d3724}
[*] Closed connection to challenge.nahamcon.com port 31098
[*] Connection closed.
**Flag:** `flag{0e42ba180089ce6e3bb50e52587d3724}`